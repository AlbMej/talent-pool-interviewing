<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Required Skills: Member of Technical Staff, Inference</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
        }
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5em;
        }
        .skill-tree {
            width: 100%;
            height: 800px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            overflow: auto;
        }
        .node circle {
            fill: #fff;
            stroke: #667eea;
            stroke-width: 3px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .node circle:hover {
            stroke-width: 5px;
            fill: #f0f0ff;
        }
        .node--internal circle {
            fill: #764ba2;
            stroke: #667eea;
        }
        .node--leaf circle {
            fill: #4CAF50;
            stroke: #45a049;
        }
        .node--certification circle {
            fill: #FF9800;
            stroke: #F57C00;
        }
        .node--qualification circle {
            fill: #2196F3;
            stroke: #1976D2;
        }
        .node--requirement circle {
            fill: #F44336;
            stroke: #D32F2F;
        }
        .node text {
            font: 14px sans-serif;
            font-weight: 500;
            pointer-events: none;
        }
        .link {
            fill: none;
            stroke: #ccc;
            stroke-width: 2px;
        }
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .controls {
            margin-bottom: 20px;
            text-align: center;
        }
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }
        button:hover {
            background: #5568d3;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Required Skills: Member of Technical Staff, Inference</h1>
        <div class="controls">
            <button onclick="zoomIn()">Zoom In</button>
            <button onclick="zoomOut()">Zoom Out</button>
            <button onclick="resetZoom()">Reset</button>
            <button onclick="expandAll()">Expand All</button>
            <button onclick="collapseAll()">Collapse All</button>
        </div>
        <div class="skill-tree" id="skill-tree"></div>
    </div>
    <div class="tooltip" id="tooltip"></div>

    <script>
        const skillTreeData = {
  "name": "Skills",
  "children": [
    {
      "name": "Technical Skills",
      "children": [
        {
          "name": "Programming Languages",
          "children": [
            {
              "name": "Python",
              "type": "skill"
            },
            {
              "name": "Rust",
              "type": "skill"
            }
          ]
        },
        {
          "name": "Frameworks",
          "children": [
            {
              "name": "PyTorch",
              "type": "skill"
            },
            {
              "name": "JAX",
              "type": "skill"
            }
          ]
        },
        {
          "name": "Tools",
          "children": [
            {
              "name": "CUDA",
              "type": "skill"
            },
            {
              "name": "CUTLASS",
              "type": "skill"
            },
            {
              "name": "Triton",
              "type": "skill"
            },
            {
              "name": "NCCL",
              "type": "skill"
            },
            {
              "name": "Kubernetes",
              "type": "skill"
            },
            {
              "name": "SGLang",
              "type": "skill"
            }
          ]
        },
        {
          "name": "Technologies",
          "children": [
            {
              "name": "GPU kernels",
              "type": "skill"
            },
            {
              "name": "code generation",
              "type": "skill"
            },
            {
              "name": "large-scale inference engines",
              "type": "skill"
            },
            {
              "name": "reinforcement learning frameworks",
              "type": "skill"
            },
            {
              "name": "high-concurrent production serving",
              "type": "skill"
            }
          ]
        }
      ]
    },
    {
      "name": "ML/AI Concepts",
      "children": [
        {
          "name": "model inference",
          "type": "skill"
        },
        {
          "name": "reinforcement learning",
          "type": "skill"
        },
        {
          "name": "test-time compute",
          "type": "skill"
        },
        {
          "name": "model-hardware co-design",
          "type": "skill"
        },
        {
          "name": "batching",
          "type": "skill"
        },
        {
          "name": "caching",
          "type": "skill"
        },
        {
          "name": "load balancing",
          "type": "skill"
        },
        {
          "name": "parallelism",
          "type": "skill"
        },
        {
          "name": "quantization",
          "type": "skill"
        },
        {
          "name": "distillation",
          "type": "skill"
        },
        {
          "name": "speculative decoding",
          "type": "skill"
        },
        {
          "name": "low-precision numerics",
          "type": "skill"
        }
      ]
    },
    {
      "name": "Methodologies & Techniques",
      "children": [
        {
          "name": "system optimizations",
          "type": "skill"
        },
        {
          "name": "low-level optimizations",
          "type": "skill"
        },
        {
          "name": "algorithmic optimizations",
          "type": "skill"
        },
        {
          "name": "testing",
          "type": "skill"
        },
        {
          "name": "benchmarking",
          "type": "skill"
        },
        {
          "name": "scaling test-time compute",
          "type": "skill"
        },
        {
          "name": "rollout in reinforcement learning training",
          "type": "skill"
        }
      ]
    },
    {
      "name": "Domain Expertise",
      "children": [
        {
          "name": "inference",
          "type": "skill"
        },
        {
          "name": "reinforcement learning training",
          "type": "skill"
        },
        {
          "name": "next-generation architectures",
          "type": "skill"
        }
      ]
    },
    {
      "name": "Experience Requirements",
      "children": [
        {
          "name": "system optimizations for model serving",
          "type": "requirement"
        },
        {
          "name": "low-level optimizations for inference",
          "type": "requirement"
        },
        {
          "name": "algorithmic optimizations for inference",
          "type": "requirement"
        },
        {
          "name": "large-scale inference engines",
          "type": "requirement"
        },
        {
          "name": "reinforcement learning frameworks",
          "type": "requirement"
        },
        {
          "name": "large-scale high-concurrent production serving",
          "type": "requirement"
        },
        {
          "name": "testing benchmarking and reliability of inference services",
          "type": "requirement"
        }
      ]
    }
  ],
  "job_id": 4533894007,
  "job_title": "Member of Technical Staff, Inference",
  "location": "Palo Alto, CA; San Francisco, CA"
};
        
        let svg, g, zoom, root, tooltip;
        let currentTransform = d3.zoomIdentity;
        
        function init() {
            tooltip = d3.select("#tooltip");
            
            svg = d3.select("#skill-tree")
                .append("svg")
                .attr("width", "100%")
                .attr("height", "100%");
            
            g = svg.append("g");
            
            zoom = d3.zoom()
                .scaleExtent([0.1, 3])
                .on("zoom", (event) => {
                    currentTransform = event.transform;
                    g.attr("transform", event.transform);
                });
            
            svg.call(zoom);
            
            root = d3.hierarchy(skillTreeData);
            root.x0 = 0;
            root.y0 = 0;
            root.descendants().forEach((d, i) => {
                d.id = i;
                d._children = d.children;
                if (d.depth > 2) d.children = null;
            });
            
            update(root);
        }
        
        function update(source) {
            const treeLayout = d3.tree().size([800, 1000]);
            treeLayout(root);
            
            const nodes = root.descendants();
            const links = root.links();
            
            const node = g.selectAll("g.node")
                .data(nodes, d => d.id);
            
            const nodeEnter = node.enter()
                .append("g")
                .attr("class", d => {
                    if (d.children) return "node node--internal";
                    if (d.data.type === "certification") return "node node--certification";
                    if (d.data.type === "qualification") return "node node--qualification";
                    if (d.data.type === "requirement") return "node node--requirement";
                    return "node node--leaf";
                })
                .attr("transform", d => `translate(${source.y0},${source.x0})`)
                .on("click", (event, d) => {
                    if (d.children) {
                        d._children = d.children;
                        d.children = null;
                    } else {
                        d.children = d._children;
                    }
                    update(d);
                })
                .on("mouseover", (event, d) => {
                    tooltip
                        .style("opacity", 1)
                        .html(`<strong>${d.data.name}</strong><br/>${d.depth > 0 ? "Click to expand/collapse" : ""}`)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 10) + "px");
                })
                .on("mouseout", () => {
                    tooltip.style("opacity", 0);
                });
            
            nodeEnter.append("circle")
                .attr("r", d => d.depth === 0 ? 15 : d.depth === 1 ? 12 : 8)
                .style("fill", d => {
                    if (d.depth === 0) return "#667eea";
                    if (d.data.type === "certification") return "#FF9800";
                    if (d.data.type === "qualification") return "#2196F3";
                    if (d.data.type === "requirement") return "#F44336";
                    return d.children ? "#764ba2" : "#4CAF50";
                });
            
            nodeEnter.append("text")
                .attr("dy", ".35em")
                .attr("x", d => d.children || d._children ? -13 : 13)
                .style("text-anchor", d => d.children || d._children ? "end" : "start")
                .text(d => d.data.name)
                .style("font-size", d => d.depth === 0 ? "16px" : d.depth === 1 ? "14px" : "12px");
            
            const nodeUpdate = nodeEnter.merge(node);
            
            nodeUpdate.transition()
                .duration(300)
                .attr("transform", d => `translate(${d.y},${d.x})`);
            
            nodeUpdate.select("circle")
                .attr("r", d => d.depth === 0 ? 15 : d.depth === 1 ? 12 : 8);
            
            const nodeExit = node.exit()
                .transition()
                .duration(300)
                .attr("transform", d => `translate(${source.y},${source.x})`)
                .remove();
            
            const link = g.selectAll("path.link")
                .data(links, d => d.target.id);
            
            const linkEnter = link.enter()
                .insert("path", "g")
                .attr("class", "link")
                .attr("d", d => {
                    const o = {x: source.x0, y: source.y0};
                    return diagonal(o, o);
                });
            
            linkEnter.merge(link)
                .transition()
                .duration(300)
                .attr("d", d => diagonal(d.source, d.target));
            
            link.exit()
                .transition()
                .duration(300)
                .attr("d", d => {
                    const o = {x: source.x, y: source.y};
                    return diagonal(o, o);
                })
                .remove();
            
            nodes.forEach(d => {
                d.x0 = d.x;
                d.y0 = d.y;
            });
        }
        
        function diagonal(s, d) {
            return `M ${s.y} ${s.x}
                    C ${(s.y + d.y) / 2} ${s.x},
                      ${(s.y + d.y) / 2} ${d.x},
                      ${d.y} ${d.x}`;
        }
        
        function zoomIn() {
            svg.transition().call(zoom.scaleBy, 1.5);
        }
        
        function zoomOut() {
            svg.transition().call(zoom.scaleBy, 0.67);
        }
        
        function resetZoom() {
            svg.transition().call(zoom.transform, d3.zoomIdentity);
        }
        
        function expandAll() {
            root.descendants().forEach(d => {
                if (d._children) {
                    d.children = d._children;
                    d._children = null;
                }
            });
            update(root);
        }
        
        function collapseAll() {
            root.descendants().forEach(d => {
                if (d.children && d.depth > 1) {
                    d._children = d.children;
                    d.children = null;
                }
            });
            update(root);
        }
        
        init();
    </script>
</body>
</html>